import { http, HttpResponse } from 'msw';
import {
  mockUser,
  mockAccessToken,
  mockLibraries,
  mockContinueWatching,
  mockRecentlyAdded,
  mockFavorites,
  mockMovieLibraryItems,
  mockTVShowLibraryItems,
  mockMusicLibraryItems,
  mockMusicTrackItems,
  mockTVEpisodeItems,
  mockVideoItems,
  mockPersonalMediaItems,
  mockPodcastItems,
} from './data';
import { generatePosterSVG, generateBackdropSVG } from './images';
import type { MediaType, MediaTypeRoute, SearchRequest, SearchResponse, MediaListResponse, MediaDetail, IngestRequest, IngestResponse } from '@/types/api';

const MOCK_SERVER_URL = 'http://localhost:8096';
const API_BASE = `${MOCK_SERVER_URL}/api/v1`;

// Helper function to validate Bearer token (mimics Python FastAPI auth)
function validateBearerToken(request: Request): boolean {
  const authHeader = request.headers.get('Authorization');
  if (!authHeader) {
    console.warn('‚ö†Ô∏è [MSW] No Authorization header');
    return false;
  }
  
  // Check for Bearer token format
  if (!authHeader.startsWith('Bearer ')) {
    console.warn('‚ö†Ô∏è [MSW] Invalid auth format, expected Bearer token');
    return false;
  }
  
  const token = authHeader.substring(7); // Remove 'Bearer ' prefix
  
  // In mock, accept the mock token
  if (token === mockAccessToken) {
    return true;
  }
  
  console.warn('‚ö†Ô∏è [MSW] Invalid token');
  return false;
}

// Helper to get media items by type
function getMediaItemsByType(type: MediaType): any[] {
  switch (type) {
    case 'movie':
      return mockMovieLibraryItems;
    case 'tv':
      return [...mockTVShowLibraryItems, ...mockTVEpisodeItems];
    case 'music':
      return [...mockMusicLibraryItems, ...mockMusicTrackItems];
    case 'podcast':
      return mockPodcastItems;
    case 'video':
      return mockVideoItems;
    case 'personal':
      return mockPersonalMediaItems;
    default:
      return [];
  }
}

// Helper to transform our MediaItem to MediaDetail format
function transformToMediaDetail(item: any): MediaDetail {
  return {
    media_id: item.Id,
    type: item.Type || item.MediaType,
    title: item.Name,
    source_type: item.SourceType || 'catalog',
    vector_hash: `vector_${item.Id}`,
    file_hash: `file_${item.Id}`,
    metadata: {
      title: item.Name,
      description: item.Overview,
      year: item.ProductionYear,
      rating: item.CommunityRating,
      content_rating: item.OfficialRating,
      genres: item.Genres,
      duration_seconds: item.RunTimeTicks ? item.RunTimeTicks / 10000000 : undefined,
      // Movie-specific
      original_title: item.OriginalTitle,
      release_date: item.ReleaseDate,
      runtime_minutes: item.RuntimeMinutes,
      cast: item.Cast,
      director: item.Director,
      // TV-specific
      series_name: item.SeriesName,
      season_number: item.SeasonNumber,
      episode_number: item.EpisodeNumber,
      air_date: item.AirDate,
      // Music-specific
      artist: item.Artist,
      album: item.Album,
      album_artist: item.AlbumArtist,
      track_number: item.TrackNumber,
      disc_number: item.DiscNumber,
      duration: item.Duration,
      // Podcast-specific
      show_name: item.ShowName,
      pub_date: item.PubDate,
      episode_title: item.EpisodeTitle,
      // Personal-specific
      capture_date: item.CaptureDate,
      device_make: item.DeviceMake,
      device_model: item.DeviceModel,
      gps_lat: item.GpsLat,
      gps_lon: item.GpsLon,
      album_name: item.AlbumName,
      // Video-specific
      platform: item.Platform,
      channel_name: item.ChannelName,
      uploader: item.Uploader,
    },
  };
}

// Create handlers for all 6 media types
const mediaTypes: Array<{ route: MediaTypeRoute; type: MediaType }> = [
  { route: 'movies', type: 'movie' },
  { route: 'tv', type: 'tv' },
  { route: 'music', type: 'music' },
  { route: 'podcasts', type: 'podcast' },
  { route: 'videos', type: 'video' },
  { route: 'personal', type: 'personal' },
];

const typeSpecificHandlers = mediaTypes.flatMap(({ route, type }) => [
  // POST /api/v1/{type}/search - Vector search for specific type
  http.post(`${API_BASE}/${route}/search`, async ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }

    const body = await request.json() as SearchRequest;
    console.log(`üîç [MSW] Search request for ${type}:`, body.query);

    const items = getMediaItemsByType(type);
    const query = body.query.toLowerCase();
    
    // Simple search - filter by name/overview
    const results = items
      .filter(item =>
        item.Name.toLowerCase().includes(query) ||
        (item.Overview && item.Overview.toLowerCase().includes(query))
      )
      .slice(0, body.k || 20)
      .map(item => ({
        media_id: item.Id,
        score: 0.95, // Mock score
        type: type,
        title: item.Name,
        preview_url: null,
      }));

    console.log(`‚úÖ [MSW] Found ${results.length} results for ${type}`);

    const response: SearchResponse = { results };
    return HttpResponse.json(response);
  }),

  // GET /api/v1/{type}/media - List all media of specific type (paginated)
  http.get(`${API_BASE}/${route}/media`, ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }

    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    console.log(`üìö [MSW] List ${type} media: limit=${limit}, offset=${offset}`);

    const items = getMediaItemsByType(type);
    const paginatedItems = items.slice(offset, offset + limit);

    const response: MediaListResponse = {
      items: paginatedItems.map(transformToMediaDetail),
      total: items.length,
    };

    console.log(`‚úÖ [MSW] Returning ${paginatedItems.length} of ${items.length} ${type} items`);
    return HttpResponse.json(response);
  }),

  // GET /api/v1/{type}/media/{media_id} - Get specific media detail
  http.get(`${API_BASE}/${route}/media/:mediaId`, ({ request, params }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }

    const { mediaId } = params;
    console.log(`üé¨ [MSW] Get ${type} detail:`, mediaId);

    const items = getMediaItemsByType(type);
    const item = items.find(i => i.Id === mediaId);

    if (item) {
      console.log(`‚úÖ [MSW] Found ${type}:`, item.Name);
      const response: MediaDetail = transformToMediaDetail(item);
      return HttpResponse.json(response);
    }

    console.log(`‚ùå [MSW] ${type} not found:`, mediaId);
    return HttpResponse.json({ detail: 'Media not found' }, { status: 404 });
  }),

  // GET /api/v1/{type}/media/{media_id}/stream - Stream media file
  http.get(`${API_BASE}/${route}/media/:mediaId/stream`, ({ request, params }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }

    const { mediaId } = params;
    console.log(`üì∫ [MSW] Stream ${type}:`, mediaId);

    // Return mock video/audio data
    return HttpResponse.text('Mock media stream data', {
      headers: {
        'Content-Type': type === 'music' || type === 'podcast' ? 'audio/mpeg' : 'video/mp4',
        'Accept-Ranges': 'bytes',
      },
    });
  }),

  // POST /api/v1/{type}/ingest/start - Ingest new media
  http.post(`${API_BASE}/${route}/ingest/start`, async ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }

    const body = await request.json() as IngestRequest;
    console.log(`üì• [MSW] Ingest ${type}:`, body.path);

    // Mock successful ingest
    const response: IngestResponse = {
      media_id: `mock_${type}_${Date.now()}`,
      file_hash: `file_hash_${Date.now()}`,
      vector_hash: `vector_hash_${Date.now()}`,
    };

    console.log(`‚úÖ [MSW] Ingested ${type}:`, response.media_id);
    return HttpResponse.json(response);
  }),
]);

// Legacy/compatibility handlers (keep for now to maintain existing functionality)
const legacyHandlers = [
  // Root endpoint - Python backend will have this
  http.get(`${MOCK_SERVER_URL}/`, () => {
    console.log('üè† [MSW] Root endpoint hit');
    return HttpResponse.json({
      message: 'BitHarbor Media Server (Mock)',
      version: '1.0.0',
      status: 'running',
    });
  }),

  // Health check endpoint - Common for FastAPI
  http.get(`${MOCK_SERVER_URL}/health`, () => {
    return HttpResponse.json({ status: 'healthy' });
  }),

  // API documentation endpoint
  http.get(`${MOCK_SERVER_URL}/api/docs`, () => {
    console.log('üìñ [MSW] API docs requested');
    return HttpResponse.json({
      title: 'BitHarbor Media Server API (Mock)',
      version: '1.0.0',
      endpoints: {
        authentication: {
          'POST /Users/AuthenticateByName': 'Login with username and password',
        },
        typeSpecificRoutes: {
          'POST /api/v1/{type}/search': 'Search media of specific type',
          'GET /api/v1/{type}/media': 'List media of specific type',
          'GET /api/v1/{type}/media/{id}': 'Get media detail',
          'GET /api/v1/{type}/media/{id}/stream': 'Stream media',
          'POST /api/v1/{type}/ingest/start': 'Ingest new media',
        },
      },
      mockData: {
        libraries: mockLibraries.length,
        movies: mockMovieLibraryItems.length,
        tvShows: mockTVShowLibraryItems.length,
        tvEpisodes: mockTVEpisodeItems.length,
        music: mockMusicLibraryItems.length,
        musicTracks: mockMusicTrackItems.length,
        videos: mockVideoItems.length,
        podcasts: mockPodcastItems.length,
        personalMedia: mockPersonalMediaItems.length,
        favorites: mockFavorites.length,
        continueWatching: mockContinueWatching.length,
        recentlyAdded: mockRecentlyAdded.length,
      },
    });
  }),

  // Authentication endpoint - Matches Python FastAPI format
  http.post(`${MOCK_SERVER_URL}/Users/AuthenticateByName`, async ({ request }) => {
    console.log('üîê [MSW] Authentication request intercepted');
    const body = await request.json() as any;
    console.log('üìù [MSW] Login attempt:', { username: body.Username, hasPassword: !!body.Pw });
    
    if (body.Username && body.Pw !== undefined) {
      console.log('‚úÖ [MSW] Authentication successful');
      return HttpResponse.json({
        User: mockUser,
        SessionInfo: {
          Id: 'mock-session-id',
          UserId: mockUser.Id,
        },
        AccessToken: mockAccessToken, // JWT token (Python will return JWT)
        ServerId: mockUser.ServerId,
      });
    }

    console.log('‚ùå [MSW] Authentication failed');
    return HttpResponse.json(
      { error: 'Invalid username or password' },
      { status: 401 }
    );
  }),

  // Get user views (libraries) - Protected endpoint
  http.get(`${MOCK_SERVER_URL}/Users/:userId/Views`, ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json(
        { detail: 'Not authenticated' },
        { status: 401 }
      );
    }
    
    console.log('üìö [MSW] Returning libraries');
    return HttpResponse.json({
      Items: mockLibraries,
      TotalRecordCount: mockLibraries.length,
    });
  }),

  // Get continue watching (resume items) - Protected endpoint
  http.get(`${MOCK_SERVER_URL}/Users/:userId/Items/Resume`, ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json(
        { detail: 'Not authenticated' },
        { status: 401 }
      );
    }
    
    return HttpResponse.json({
      Items: mockContinueWatching,
      TotalRecordCount: mockContinueWatching.length,
    });
  }),

  // Get recently added (latest items) - Protected endpoint
  http.get(`${MOCK_SERVER_URL}/Users/:userId/Items/Latest`, ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json(
        { detail: 'Not authenticated' },
        { status: 401 }
      );
    }
    
    return HttpResponse.json(mockRecentlyAdded);
  }),

  // Get favorite items or library items - Protected endpoint
  http.get(`${MOCK_SERVER_URL}/Users/:userId/Items`, ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json(
        { detail: 'Not authenticated' },
        { status: 401 }
      );
    }
    
    const url = new URL(request.url);
    const filters = url.searchParams.get('Filters');
    const searchTerm = url.searchParams.get('SearchTerm');
    
    // Check if this is a search request
    if (searchTerm) {
      console.log('üîç [MSW] Search request:', searchTerm);
      const allItems = [...mockMovieLibraryItems, ...mockTVShowLibraryItems, ...mockMusicLibraryItems];
      const results = allItems.filter(item =>
        item.Name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        (item.Overview && item.Overview.toLowerCase().includes(searchTerm.toLowerCase()))
      );
      console.log(`‚úÖ [MSW] Found ${results.length} search results`);
      return HttpResponse.json({
        Items: results,
        TotalRecordCount: results.length,
      });
    }
    
    // Check if this is a favorites request
    if (filters && filters.includes('IsFavorite')) {
      console.log('‚≠ê [MSW] Favorites request intercepted');
      return HttpResponse.json({
        Items: mockFavorites,
        TotalRecordCount: mockFavorites.length,
      });
    }
    
    // Otherwise handle as regular library items request
    const parentId = url.searchParams.get('ParentId');
    const sortBy = url.searchParams.get('SortBy') || 'SortName';
    const sortOrder = url.searchParams.get('SortOrder') || 'Ascending';
    const genres = url.searchParams.get('Genres');
    
    console.log('üìö [MSW] Library items request:', { parentId, sortBy, sortOrder, genres });
    
    // Determine which library
    let items: any[] = [];
    if (parentId === 'mock-library-movies') {
      items = [...mockMovieLibraryItems];
    } else if (parentId === 'mock-library-tvshows') {
      items = [...mockTVShowLibraryItems, ...mockTVEpisodeItems];
    } else if (parentId === 'mock-library-music') {
      items = [...mockMusicLibraryItems, ...mockMusicTrackItems];
    } else if (parentId === 'mock-library-videos') {
      items = [...mockVideoItems];
    } else if (parentId === 'mock-library-podcasts') {
      items = [...mockPodcastItems];
    } else if (parentId === 'mock-library-personal') {
      items = [...mockPersonalMediaItems];
    } else {
      // Return all items if no parent specified
      items = [
        ...mockMovieLibraryItems,
        ...mockTVShowLibraryItems,
        ...mockTVEpisodeItems,
        ...mockMusicLibraryItems,
        ...mockMusicTrackItems,
        ...mockVideoItems,
        ...mockPodcastItems,
        ...mockPersonalMediaItems,
      ];
    }
    
    // Filter by genre if specified
    if (genres) {
      const genreList = genres.split(',');
      items = items.filter(item => 
        item.Genres && item.Genres.some((g: string) => genreList.includes(g))
      );
    }
    
    // Sort items
    items.sort((a, b) => {
      let compareResult = 0;
      
      switch (sortBy) {
        case 'SortName':
          compareResult = a.Name.localeCompare(b.Name);
          break;
        case 'PremiereDate':
        case 'DateCreated':
          const dateA = new Date(a.PremiereDate || 0).getTime();
          const dateB = new Date(b.PremiereDate || 0).getTime();
          compareResult = dateA - dateB;
          break;
        case 'CommunityRating':
          compareResult = (a.CommunityRating || 0) - (b.CommunityRating || 0);
          break;
        default:
          compareResult = a.Name.localeCompare(b.Name);
      }
      
      return sortOrder === 'Descending' ? -compareResult : compareResult;
    });
    
    console.log(`‚úÖ [MSW] Returning ${items.length} items`);
    
    return HttpResponse.json({
      Items: items,
      TotalRecordCount: items.length,
    });
  }),

  // Get single item by ID - Protected endpoint
  http.get(`${MOCK_SERVER_URL}/Users/:userId/Items/:itemId`, ({ request, params }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json(
        { detail: 'Not authenticated' },
        { status: 401 }
      );
    }
    
    const { itemId } = params;
    console.log('üé¨ [MSW] Item detail request:', itemId);
    
    const allItems = [
      ...mockContinueWatching,
      ...mockRecentlyAdded,
      ...mockFavorites,
      ...mockMovieLibraryItems,
      ...mockTVShowLibraryItems,
      ...mockTVEpisodeItems,
      ...mockMusicLibraryItems,
      ...mockMusicTrackItems,
      ...mockVideoItems,
      ...mockPodcastItems,
      ...mockPersonalMediaItems,
    ];
    
    const item = allItems.find(i => i.Id === itemId);
    
    if (item) {
      console.log('‚úÖ [MSW] Found item:', item.Name);
      return HttpResponse.json(item);
    }
    
    console.log('‚ùå [MSW] Item not found:', itemId);
    return HttpResponse.json(
      { error: 'Item not found' },
      { status: 404 }
    );
  }),

  // Mark item as favorite
  http.post(`${MOCK_SERVER_URL}/Users/:userId/FavoriteItems/:itemId`, ({ request, params }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }
    
    const { itemId } = params;
    console.log('‚≠ê [MSW] Marking item as favorite:', itemId);
    
    const allCollections = [
      mockContinueWatching,
      mockRecentlyAdded,
      mockFavorites,
      mockMovieLibraryItems,
      mockTVShowLibraryItems,
      mockMusicLibraryItems,
    ];
    
    for (const collection of allCollections) {
      const item = collection.find((i: any) => i.Id === itemId);
      if (item && item.UserData) {
        item.UserData.IsFavorite = true;
        console.log('‚úÖ [MSW] Item marked as favorite:', item.Name);
        break;
      }
    }
    
    return HttpResponse.json({ success: true }, { status: 200 });
  }),

  // Remove item from favorites
  http.delete(`${MOCK_SERVER_URL}/Users/:userId/FavoriteItems/:itemId`, ({ request, params }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }
    
    const { itemId } = params;
    console.log('üíî [MSW] Removing item from favorites:', itemId);
    
    const allCollections = [
      mockContinueWatching,
      mockRecentlyAdded,
      mockFavorites,
      mockMovieLibraryItems,
      mockTVShowLibraryItems,
      mockMusicLibraryItems,
    ];
    
    for (const collection of allCollections) {
      const item = collection.find((i: any) => i.Id === itemId);
      if (item && item.UserData) {
        item.UserData.IsFavorite = false;
        console.log('‚úÖ [MSW] Item removed from favorites:', item.Name);
        break;
      }
    }
    
    return HttpResponse.json({ success: true }, { status: 200 });
  }),

  // Get system info (for server discovery)
  http.get(`${MOCK_SERVER_URL}/System/Info/Public`, () => {
    console.log('üåê [MSW] System info request intercepted');
    return HttpResponse.json({
      LocalAddress: MOCK_SERVER_URL,
      ServerName: 'Mock BitHarbor-web Server',
      Version: '10.8.0',
      Id: 'mock-server-id',
    });
  }),

  // Image endpoint - return realistic poster
  http.get(`${MOCK_SERVER_URL}/Items/:itemId/Images/:imageType`, ({ params }) => {
    const { itemId, imageType } = params;
    
    const allItems = [
      ...mockContinueWatching,
      ...mockRecentlyAdded,
      ...mockFavorites,
      ...mockMovieLibraryItems,
      ...mockTVShowLibraryItems,
      ...mockMusicLibraryItems,
    ];
    const item = allItems.find(i => i.Id === itemId);
    
    let svg: string;
    if (imageType === 'Backdrop') {
      svg = generateBackdropSVG(itemId as string, item?.Name || 'Unknown');
    } else {
      svg = generatePosterSVG(
        itemId as string,
        item?.Name || 'Unknown',
        item?.Type || 'Media'
      );
    }
    
    return HttpResponse.text(svg, {
      headers: { 'Content-Type': 'image/svg+xml' },
    });
  }),

  // Report playback progress
  http.post(`${MOCK_SERVER_URL}/Sessions/Playing/Progress`, async ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }
    
    const body = await request.json() as any;
    console.log('üìä [MSW] Playback progress reported:', {
      itemId: body.ItemId,
      position: body.PositionTicks / 10000000,
      isPaused: body.IsPaused,
    });
    return HttpResponse.json({ success: true });
  }),

  // Report playback stopped
  http.post(`${MOCK_SERVER_URL}/Sessions/Playing/Stopped`, async ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }
    
    const body = await request.json() as any;
    console.log('‚èπÔ∏è [MSW] Playback stopped:', {
      itemId: body.ItemId,
      position: body.PositionTicks / 10000000,
    });
    return HttpResponse.json({ success: true });
  }),

  // Mark item as played
  http.post(`${MOCK_SERVER_URL}/Users/:userId/PlayedItems/:itemId`, ({ request, params }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }
    
    console.log('‚úÖ [MSW] Item marked as played:', params.itemId);
    return HttpResponse.json({ success: true });
  }),
];

// Export all handlers (type-specific + legacy)
export const handlers = [...typeSpecificHandlers, ...legacyHandlers];
    console.log('üè† [MSW] Root endpoint hit');
    return HttpResponse.json({
      message: 'BitHarbor Media Server (Mock)',
      version: '1.0.0',
      status: 'running',
    });
  }),

  // Health check endpoint - Common for FastAPI
  http.get(`${MOCK_SERVER_URL}/health`, () => {
    return HttpResponse.json({ status: 'healthy' });
  }),

  // API documentation endpoint - Shows available endpoints (like FastAPI /docs)
  http.get(`${MOCK_SERVER_URL}/api/docs`, () => {
    console.log('üìñ [MSW] API docs requested');
    return HttpResponse.json({
      title: 'BitHarbor Media Server API (Mock)',
      version: '1.0.0',
      endpoints: {
        authentication: {
          'POST /Users/AuthenticateByName': 'Login with username and password',
        },
        libraries: {
          'GET /Users/{userId}/Views': 'Get all media libraries',
          'GET /Users/{userId}/Items': 'Get items from a library (supports filtering, sorting)',
          'GET /Users/{userId}/Items/{itemId}': 'Get single item details',
          'GET /Users/{userId}/Items/Resume': 'Get continue watching items',
          'GET /Users/{userId}/Items/Latest': 'Get recently added items',
        },
        favorites: {
          'POST /Users/{userId}/FavoriteItems/{itemId}': 'Mark item as favorite',
          'DELETE /Users/{userId}/FavoriteItems/{itemId}': 'Remove from favorites',
        },
        playback: {
          'POST /Sessions/Playing/Progress': 'Report playback progress',
          'POST /Sessions/Playing/Stopped': 'Report playback stopped',
          'POST /Users/{userId}/PlayedItems/{itemId}': 'Mark item as played',
        },
        images: {
          'GET /Items/{itemId}/Images/{imageType}': 'Get item image (Primary, Backdrop)',
        },
      },
      mockData: {
        libraries: mockLibraries.length,
        movies: mockMovieLibraryItems.length,
        tvShows: mockTVShowLibraryItems.length,
        tvEpisodes: mockTVEpisodeItems.length,
        music: mockMusicLibraryItems.length,
        musicTracks: mockMusicTrackItems.length,
        videos: mockVideoItems.length,
        podcasts: mockPodcastItems.length,
        personalMedia: mockPersonalMediaItems.length,
        favorites: mockFavorites.length,
        continueWatching: mockContinueWatching.length,
        recentlyAdded: mockRecentlyAdded.length,
      },
    });
  }),

  // Authentication endpoint - Matches Python FastAPI format
  http.post(`${MOCK_SERVER_URL}/Users/AuthenticateByName`, async ({ request }) => {
    console.log('üîê [MSW] Authentication request intercepted');
    const body = await request.json() as any;
    console.log('üìù [MSW] Login attempt:', { username: body.Username, hasPassword: !!body.Pw });
    
    if (body.Username && body.Pw !== undefined) {
      console.log('‚úÖ [MSW] Authentication successful');
      return HttpResponse.json({
        User: mockUser,
        SessionInfo: {
          Id: 'mock-session-id',
          UserId: mockUser.Id,
        },
        AccessToken: mockAccessToken, // JWT token (Python will return JWT)
        ServerId: mockUser.ServerId,
      });
    }

    console.log('‚ùå [MSW] Authentication failed');
    return HttpResponse.json(
      { error: 'Invalid username or password' },
      { status: 401 }
    );
  }),

  // Get user views (libraries) - Protected endpoint
  http.get(`${MOCK_SERVER_URL}/Users/:userId/Views`, ({ request }) => {
    // Python FastAPI will validate JWT token here
    if (!validateBearerToken(request)) {
      return HttpResponse.json(
        { detail: 'Not authenticated' },
        { status: 401 }
      );
    }
    
    console.log('üìö [MSW] Returning libraries');
    return HttpResponse.json({
      Items: mockLibraries,
      TotalRecordCount: mockLibraries.length,
    });
  }),

  // Get continue watching (resume items) - Protected endpoint
  http.get(`${MOCK_SERVER_URL}/Users/:userId/Items/Resume`, ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json(
        { detail: 'Not authenticated' },
        { status: 401 }
      );
    }
    
    return HttpResponse.json({
      Items: mockContinueWatching,
      TotalRecordCount: mockContinueWatching.length,
    });
  }),

  // Get recently added (latest items) - Protected endpoint
  http.get(`${MOCK_SERVER_URL}/Users/:userId/Items/Latest`, ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json(
        { detail: 'Not authenticated' },
        { status: 401 }
      );
    }
    
    return HttpResponse.json(mockRecentlyAdded);
  }),

  // Get favorite items or library items - Protected endpoint
  http.get(`${MOCK_SERVER_URL}/Users/:userId/Items`, ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json(
        { detail: 'Not authenticated' },
        { status: 401 }
      );
    }
    
    const url = new URL(request.url);
    const filters = url.searchParams.get('Filters');
    const searchTerm = url.searchParams.get('SearchTerm');
    
    // Check if this is a search request
    if (searchTerm) {
      console.log('üîç [MSW] Search request:', searchTerm);
      const allItems = [...mockMovieLibraryItems, ...mockTVShowLibraryItems, ...mockMusicLibraryItems];
      const results = allItems.filter(item =>
        item.Name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        (item.Overview && item.Overview.toLowerCase().includes(searchTerm.toLowerCase()))
      );
      console.log(`‚úÖ [MSW] Found ${results.length} search results`);
      return HttpResponse.json({
        Items: results,
        TotalRecordCount: results.length,
      });
    }
    
    // Check if this is a favorites request
    if (filters && filters.includes('IsFavorite')) {
      console.log('‚≠ê [MSW] Favorites request intercepted');
      return HttpResponse.json({
        Items: mockFavorites,
        TotalRecordCount: mockFavorites.length,
      });
    }
    
    // Otherwise handle as regular library items request
    const parentId = url.searchParams.get('ParentId');
    const sortBy = url.searchParams.get('SortBy') || 'SortName';
    const sortOrder = url.searchParams.get('SortOrder') || 'Ascending';
    const genres = url.searchParams.get('Genres');
    
    console.log('üìö [MSW] Library items request:', { parentId, sortBy, sortOrder, genres });
    
    // Determine which library
    let items: any[] = [];
    if (parentId === 'mock-library-movies') {
      items = [...mockMovieLibraryItems];
    } else if (parentId === 'mock-library-tvshows') {
      items = [...mockTVShowLibraryItems, ...mockTVEpisodeItems];
    } else if (parentId === 'mock-library-music') {
      items = [...mockMusicLibraryItems, ...mockMusicTrackItems];
    } else if (parentId === 'mock-library-videos') {
      items = [...mockVideoItems];
    } else if (parentId === 'mock-library-podcasts') {
      items = [...mockPodcastItems];
    } else if (parentId === 'mock-library-personal') {
      items = [...mockPersonalMediaItems];
    } else {
      // Return all items if no parent specified
      items = [
        ...mockMovieLibraryItems,
        ...mockTVShowLibraryItems,
        ...mockTVEpisodeItems,
        ...mockMusicLibraryItems,
        ...mockMusicTrackItems,
        ...mockVideoItems,
        ...mockPodcastItems,
        ...mockPersonalMediaItems,
      ];
    }
    
    // Filter by genre if specified
    if (genres) {
      const genreList = genres.split(',');
      items = items.filter(item => 
        item.Genres && item.Genres.some((g: string) => genreList.includes(g))
      );
    }
    
    // Sort items
    items.sort((a, b) => {
      let compareResult = 0;
      
      switch (sortBy) {
        case 'SortName':
          compareResult = a.Name.localeCompare(b.Name);
          break;
        case 'PremiereDate':
        case 'DateCreated':
          const dateA = new Date(a.PremiereDate || 0).getTime();
          const dateB = new Date(b.PremiereDate || 0).getTime();
          compareResult = dateA - dateB; // Oldest first for Ascending
          break;
        case 'CommunityRating':
          compareResult = (a.CommunityRating || 0) - (b.CommunityRating || 0); // Lowest first for Ascending
          break;
        default:
          compareResult = a.Name.localeCompare(b.Name);
      }
      
      return sortOrder === 'Descending' ? -compareResult : compareResult;
    });
    
    console.log(`‚úÖ [MSW] Returning ${items.length} items`);
    
    return HttpResponse.json({
      Items: items,
      TotalRecordCount: items.length,
    });
  }),

  // Get single item by ID - Protected endpoint
  http.get(`${MOCK_SERVER_URL}/Users/:userId/Items/:itemId`, ({ request, params }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json(
        { detail: 'Not authenticated' },
        { status: 401 }
      );
    }
    
    const { itemId } = params;
    console.log('üé¨ [MSW] Item detail request:', itemId);
    
    const allItems = [
      ...mockContinueWatching,
      ...mockRecentlyAdded,
      ...mockFavorites,
      ...mockMovieLibraryItems,
      ...mockTVShowLibraryItems,
      ...mockTVEpisodeItems,
      ...mockMusicLibraryItems,
      ...mockMusicTrackItems,
      ...mockVideoItems,
      ...mockPodcastItems,
      ...mockPersonalMediaItems,
    ];
    
    const item = allItems.find(i => i.Id === itemId);
    
    if (item) {
      console.log('‚úÖ [MSW] Found item:', item.Name);
      return HttpResponse.json(item);
    }
    
    console.log('‚ùå [MSW] Item not found:', itemId);
    return HttpResponse.json(
      { error: 'Item not found' },
      { status: 404 }
    );
  }),

  // Mark item as favorite
  http.post(`${MOCK_SERVER_URL}/Users/:userId/FavoriteItems/:itemId`, ({ request, params }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }
    
    const { itemId } = params;
    console.log('‚≠ê [MSW] Marking item as favorite:', itemId);
    
    // Find and update the item across all collections
    const allCollections = [
      mockContinueWatching,
      mockRecentlyAdded,
      mockFavorites,
      mockMovieLibraryItems,
      mockTVShowLibraryItems,
      mockMusicLibraryItems,
    ];
    
    for (const collection of allCollections) {
      const item = collection.find((i: any) => i.Id === itemId);
      if (item && item.UserData) {
        item.UserData.IsFavorite = true;
        console.log('‚úÖ [MSW] Item marked as favorite:', item.Name);
        break;
      }
    }
    
    return HttpResponse.json({ success: true }, { status: 200 });
  }),

  // Remove item from favorites
  http.delete(`${MOCK_SERVER_URL}/Users/:userId/FavoriteItems/:itemId`, ({ request, params }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }
    
    const { itemId } = params;
    console.log('üíî [MSW] Removing item from favorites:', itemId);
    
    // Find and update the item across all collections
    const allCollections = [
      mockContinueWatching,
      mockRecentlyAdded,
      mockFavorites,
      mockMovieLibraryItems,
      mockTVShowLibraryItems,
      mockMusicLibraryItems,
    ];
    
    for (const collection of allCollections) {
      const item = collection.find((i: any) => i.Id === itemId);
      if (item && item.UserData) {
        item.UserData.IsFavorite = false;
        console.log('‚úÖ [MSW] Item removed from favorites:', item.Name);
        break;
      }
    }
    
    return HttpResponse.json({ success: true }, { status: 200 });
  }),

  // Get system info (for server discovery)
  http.get(`${MOCK_SERVER_URL}/System/Info/Public`, () => {
    console.log('üåê [MSW] System info request intercepted');
    return HttpResponse.json({
      LocalAddress: MOCK_SERVER_URL,
      ServerName: 'Mock BitHarbor-web Server',
      Version: '10.8.0',
      Id: 'mock-server-id',
    });
  }),

  // Image endpoint - return realistic poster
  http.get(`${MOCK_SERVER_URL}/Items/:itemId/Images/:imageType`, ({ params }) => {
    const { itemId, imageType } = params;
    
    // Find the item to get its title and type - check all item sources
    const allItems = [
      ...mockContinueWatching,
      ...mockRecentlyAdded,
      ...mockFavorites,
      ...mockMovieLibraryItems,
      ...mockTVShowLibraryItems,
      ...mockMusicLibraryItems,
    ];
    const item = allItems.find(i => i.Id === itemId);
    
    let svg: string;
    if (imageType === 'Backdrop') {
      svg = generateBackdropSVG(itemId as string, item?.Name || 'Unknown');
    } else {
      // Primary poster
      svg = generatePosterSVG(
        itemId as string,
        item?.Name || 'Unknown',
        item?.Type || 'Media'
      );
    }
    
    return HttpResponse.text(svg, {
      headers: { 'Content-Type': 'image/svg+xml' },
    });
  }),

  // Report playback progress
  http.post(`${MOCK_SERVER_URL}/Sessions/Playing/Progress`, async ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }
    
    const body = await request.json() as any;
    console.log('üìä [MSW] Playback progress reported:', {
      itemId: body.ItemId,
      position: body.PositionTicks / 10000000,
      isPaused: body.IsPaused,
    });
    return HttpResponse.json({ success: true });
  }),

  // Report playback stopped
  http.post(`${MOCK_SERVER_URL}/Sessions/Playing/Stopped`, async ({ request }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }
    
    const body = await request.json() as any;
    console.log('‚èπÔ∏è [MSW] Playback stopped:', {
      itemId: body.ItemId,
      position: body.PositionTicks / 10000000,
    });
    return HttpResponse.json({ success: true });
  }),

  // Mark item as played
  http.post(`${MOCK_SERVER_URL}/Users/:userId/PlayedItems/:itemId`, ({ request, params }) => {
    if (!validateBearerToken(request)) {
      return HttpResponse.json({ detail: 'Not authenticated' }, { status: 401 });
    }
    
    console.log('‚úÖ [MSW] Item marked as played:', params.itemId);
    return HttpResponse.json({ success: true });
  }),
];
